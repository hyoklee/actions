<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: HDF5 Virtual File Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Help us improve by taking our short survey: <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript">
    DoxygenAwesomeTabs.init()
</script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-57FMZK4S7X"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-57FMZK4S7X');
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;Last Updated on 2026-02-28</span>
   </div>
   <div id="projectbrief">The HDF5 Field Guide</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_f_t_s.html"><span>Full-Text&#160;Search</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_v_f_l_t_n.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HDF5 Virtual File Layer</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Navigate back: <a class="el" href="index.html">Main</a> / <a class="el" href="_t_n.html">Technical Notes</a> </p><hr  />
<h1><a class="anchor" id="sec_vfl_intro"></a>
Introduction</h1>
<p>The HDF5 file format describes how HDF5 data structures and dataset raw data are mapped to a linear format address space and the HDF5 library implements that bidirectional mapping in terms of an API. However, the HDF5 format specifications do not indicate how the format address space is mapped onto storage and HDF (version 5 and earlier) simply mapped the format address space directly onto a single file by convention.</p>
<p>Since early versions of HDF5 it became apparent that users want the ability to map the format address space onto different types of storage (a single file, multiple files, local memory, global memory, network distributed global memory, a network protocol, etc.) with various types of maps. For instance, some users want to be able to handle very large format address spaces on operating systems that support only 2GB files by partitioning the format address space into equal-sized parts each served by a separate file. Other users want the same multi-file storage capability but want to partition the address space according to purpose (raw data in one file, object headers in another, global heap in a third, etc.) in order to improve I/O speeds.</p>
<p>In fact, the number of storage variations is probably larger than the number of methods that the HDF5 team is capable of implementing and supporting. Therefore, a Virtual File Layer API is being implemented which will allow application teams or departments to design and implement their own mapping between the HDF5 format address space and storage, with each mapping being a separate file driver (possibly written in terms of other file drivers). The HDF5 team will provide a small set of useful file drivers which will also serve as examples for those who which to write their own: </p><table class="doxtable">
<tr>
<td><a class="el" href="_h5_f_dsec2_8h.html#a15ae1f958e1cf11cb239916d76b10606">H5FD_SEC2</a></td><td>This is the default driver which uses Posix file-system functions like read and write to perform I/O to a single file. All I/O requests are unbuffered although the driver does optimize file seeking operations to some extent.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_dstdio_8h.html#a030a03b96a9f6e46035ce64e25389085">H5FD_STDIO</a></td><td>This driver uses functions from 'stdio.h' to perform buffered I/O to a single file.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_dcore_8h.html#ae449696f6b86abcd1120beab21fff76a">H5FD_CORE</a></td><td>This driver performs I/O directly to memory and can be used to create small temporary files that never exist on permanent storage. This type of storage is generally very fast since the I/O consists only of memory-to-memory copy operations.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_dmpio_8h.html#a7a231bc1d78744088a4e1d297284cabf">H5FD_MPIO</a></td><td>This is the driver of choice for accessing files in parallel using MPI and MPI-IO. It is only predefined if the library is compiled with parallel I/O support.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_dfamily_8h.html#adbf24f060712550a2a9649589a6060c6">H5FD_FAMILY</a></td><td>Large format address spaces are partitioned into more manageable pieces and sent to separate storage locations using an underlying driver of the user's choice. <a class="el" href="_h5_t_o_o_l__r_t__u_g.html">The HDF5 h5repart Tool</a> can be used to change the sizes of the family members when stored as files or to convert a family of files to a single file or vice versa.   </td></tr>
</table>
<h1><a class="anchor" id="sec_vfl_use"></a>
Using a File Driver</h1>
<p>Most application writers will use a driver defined by the HDF5 library or contributed by another programming team. This chapter describes how existing drivers are used.</p>
<h2><a class="anchor" id="subsec_vfl_use_hdr"></a>
Driver Header Files</h2>
<p>Each file driver is defined in its own public header file which should be included by any application which plans to use that driver. The predefined drivers are in header files whose names begin with 'H5FD' followed by the driver name and '.h'. The 'hdf5.h' header file includes all the predefined driver header files.</p>
<p>Once the appropriate header file is included a symbol of the form 'H5FD_' followed by the upper-case driver name will be the driver identification number.(The driver name is by convention and might not apply to drivers which are not distributed with HDF5.) However, the value may change if the library is closed (e.g., by calling <a class="el" href="group___h5.html#ga8a9fe81dcf66972ed75ea481e7750574" title="Flushes all data to disk, closes all open objects, and releases memory.">H5close</a>) and the symbol is referenced again.</p>
<h2><a class="anchor" id="subsec_vfl_use_create"></a>
Creating and Opening Files</h2>
<p>In order to create or open a file one must define the method by which the storage is accessed(The access method also indicates how to translate the storage name to a storage server such as a file, network protocol, or memory.) and does so by creating a file access property list(The term "file access property list" is a misnomer since storage isn't required to be a file.) which is passed to the <a class="el" href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4" title="Creates an HDF5 file.">H5Fcreate</a> or <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> function. A default file access property list is created by calling <a class="el" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa" title="Creates a new property list as an instance of a property list class.">H5Pcreate</a> and then the file driver information is inserted by calling a driver initialization function such as <a class="el" href="group___f_a_p_l.html#ga045ab2235f949a47bbb83e1b4c7e6e4d" title="Sets the file access property list to use the family driver.">H5Pset_fapl_family</a>: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a>(<a class="code hl_define" href="_h5_ppublic_8h.html#a60ec2d4334addfc0eda89614598ee38e">H5P_FILE_ACCESS</a>);</div>
<div class="line"><span class="keywordtype">size_t</span> member_size = 100*1024*1024; <span class="comment">/*100MB*/</span></div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga045ab2235f949a47bbb83e1b4c7e6e4d">H5Pset_fapl_family</a>(fapl, member_size, <a class="code hl_define" href="_h5_ppublic_8h.html#afa85e97bfbf9bf1c58e39263846c568f">H5P_DEFAULT</a>);</div>
<div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file = <a class="code hl_function" href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4">H5Fcreate</a>(<span class="stringliteral">&quot;foo%05d.h5&quot;</span>, <a class="code hl_define" href="_h5_fpublic_8h.html#a5a2d6726f9ad8d2bca8df2b817e5ad6a">H5F_ACC_TRUNC</a>, <a class="code hl_define" href="_h5_ppublic_8h.html#afa85e97bfbf9bf1c58e39263846c568f">H5P_DEFAULT</a>, fapl);</div>
<div class="line"><a class="code hl_function" href="group___p_l_c_r.html#ga5dce61149211d3ef319452aa598887fb">H5Pclose</a>(fapl);</div>
<div class="ttc" id="a_h5_fpublic_8h_html_a5a2d6726f9ad8d2bca8df2b817e5ad6a"><div class="ttname"><a href="_h5_fpublic_8h.html#a5a2d6726f9ad8d2bca8df2b817e5ad6a">H5F_ACC_TRUNC</a></div><div class="ttdeci">#define H5F_ACC_TRUNC</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:30</div></div>
<div class="ttc" id="a_h5_ipublic_8h_html_a0045db7ff9c22ad35db6ae91662e1943"><div class="ttname"><a href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a></div><div class="ttdeci">int64_t hid_t</div><div class="ttdef"><b>Definition</b> H5Ipublic.h:60</div></div>
<div class="ttc" id="a_h5_ppublic_8h_html_a60ec2d4334addfc0eda89614598ee38e"><div class="ttname"><a href="_h5_ppublic_8h.html#a60ec2d4334addfc0eda89614598ee38e">H5P_FILE_ACCESS</a></div><div class="ttdeci">#define H5P_FILE_ACCESS</div><div class="ttdef"><b>Definition</b> H5Ppublic.h:56</div></div>
<div class="ttc" id="a_h5_ppublic_8h_html_afa85e97bfbf9bf1c58e39263846c568f"><div class="ttname"><a href="_h5_ppublic_8h.html#afa85e97bfbf9bf1c58e39263846c568f">H5P_DEFAULT</a></div><div class="ttdeci">#define H5P_DEFAULT</div><div class="ttdef"><b>Definition</b> H5Ppublic.h:220</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga045ab2235f949a47bbb83e1b4c7e6e4d"><div class="ttname"><a href="group___f_a_p_l.html#ga045ab2235f949a47bbb83e1b4c7e6e4d">H5Pset_fapl_family</a></div><div class="ttdeci">herr_t H5Pset_fapl_family(hid_t fapl_id, hsize_t memb_size, hid_t memb_fapl_id)</div><div class="ttdoc">Sets the file access property list to use the family driver.</div></div>
<div class="ttc" id="agroup___h5_f_html_gae64b51ee9ac0781bc4ccc599d98387f4"><div class="ttname"><a href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4">H5Fcreate</a></div><div class="ttdeci">hid_t H5Fcreate(const char *filename, unsigned flags, hid_t fcpl_id, hid_t fapl_id)</div><div class="ttdoc">Creates an HDF5 file.</div></div>
<div class="ttc" id="agroup___p_l_c_r_html_ga5dce61149211d3ef319452aa598887fb"><div class="ttname"><a href="group___p_l_c_r.html#ga5dce61149211d3ef319452aa598887fb">H5Pclose</a></div><div class="ttdeci">herr_t H5Pclose(hid_t plist_id)</div><div class="ttdoc">Terminates access to a property list.</div></div>
<div class="ttc" id="agroup___p_l_c_r_html_gaf1b11da01d4d45d788c45f8bc5f0cbfa"><div class="ttname"><a href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a></div><div class="ttdeci">hid_t H5Pcreate(hid_t cls_id)</div><div class="ttdoc">Creates a new property list as an instance of a property list class.</div></div>
</div><!-- fragment --><p>Each file driver will have its own initialization function whose name is H5Pset_fapl_ followed by the driver name and which takes a file access property list as the first argument followed by additional driver-dependent arguments.</p>
<p>An alternative to using the driver initialization function is to set the driver directly using the <a class="el" href="group___f_a_p_l.html#ga8bcce60e23e9d2a019212c63b146502e" title="Sets a file driver.">H5Pset_driver</a> function.(This function is overloaded to operate on data transfer property lists also, as described below.) Its second argument is the file driver identifier, which may have a different numeric value from run to run depending on the order in which the file drivers are registered with the library. The third argument encapsulates the additional arguments of the driver initialization function. This method only works if the file driver writer has made the driver-specific property list structure a public datatype, which is often not the case. </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a>(<a class="code hl_define" href="_h5_ppublic_8h.html#a60ec2d4334addfc0eda89614598ee38e">H5P_FILE_ACCESS</a>);</div>
<div class="line"><span class="keyword">static</span> H5FD_family_fapl_t fa = {100*1024*1024, <a class="code hl_define" href="_h5_ppublic_8h.html#afa85e97bfbf9bf1c58e39263846c568f">H5P_DEFAULT</a>};</div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga8bcce60e23e9d2a019212c63b146502e">H5Pset_driver</a>(fapl, <a class="code hl_define" href="_h5_f_dfamily_8h.html#adbf24f060712550a2a9649589a6060c6">H5FD_FAMILY</a>, &amp;fa);</div>
<div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file = <a class="code hl_function" href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4">H5Fcreate</a>(<span class="stringliteral">&quot;foo.h5&quot;</span>, <a class="code hl_define" href="_h5_fpublic_8h.html#a5a2d6726f9ad8d2bca8df2b817e5ad6a">H5F_ACC_TRUNC</a>, <a class="code hl_define" href="_h5_ppublic_8h.html#afa85e97bfbf9bf1c58e39263846c568f">H5P_DEFAULT</a>, fapl);</div>
<div class="line"><a class="code hl_function" href="group___p_l_c_r.html#ga5dce61149211d3ef319452aa598887fb">H5Pclose</a>(fapl);</div>
<div class="ttc" id="a_h5_f_dfamily_8h_html_adbf24f060712550a2a9649589a6060c6"><div class="ttname"><a href="_h5_f_dfamily_8h.html#adbf24f060712550a2a9649589a6060c6">H5FD_FAMILY</a></div><div class="ttdeci">#define H5FD_FAMILY</div><div class="ttdef"><b>Definition</b> H5FDfamily.h:23</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga8bcce60e23e9d2a019212c63b146502e"><div class="ttname"><a href="group___f_a_p_l.html#ga8bcce60e23e9d2a019212c63b146502e">H5Pset_driver</a></div><div class="ttdeci">herr_t H5Pset_driver(hid_t plist_id, hid_t driver_id, const void *driver_info)</div><div class="ttdoc">Sets a file driver.</div></div>
</div><!-- fragment --><p>It is also possible to query the file driver information from a file access property list by calling <a class="el" href="group___f_a_p_l.html#ga43a733fe9723dd15f5ad7abda909a1b8" title="Returns low-lever driver identifier.">H5Pget_driver</a> to determine the driver and then calling a driver-defined query function to obtain the driver information: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> driver = <a class="code hl_function" href="group___f_a_p_l.html#ga43a733fe9723dd15f5ad7abda909a1b8">H5Pget_driver</a>(fapl);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_f_dsec2_8h.html#a15ae1f958e1cf11cb239916d76b10606">H5FD_SEC2</a>==driver) {</div>
<div class="line">    <span class="comment">/*nothing further to get*/</span></div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_f_dfamily_8h.html#adbf24f060712550a2a9649589a6060c6">H5FD_FAMILY</a>==driver) {</div>
<div class="line">    <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> member_fapl;</div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a> member_size;</div>
<div class="line">    <a class="code hl_function" href="group___f_a_p_l.html#ga9195cb7b6c33ed8947486669702a4375">H5Pget_fapl_family</a>(fapl, &amp;member_size, &amp;member_fapl);</div>
<div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (....) {</div>
<div class="line">    ....</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dsec2_8h_html_a15ae1f958e1cf11cb239916d76b10606"><div class="ttname"><a href="_h5_f_dsec2_8h.html#a15ae1f958e1cf11cb239916d76b10606">H5FD_SEC2</a></div><div class="ttdeci">#define H5FD_SEC2</div><div class="ttdef"><b>Definition</b> H5FDsec2.h:24</div></div>
<div class="ttc" id="a_h5public_8h_html_a8c86e866f40d7167cf9a1934c72b856f"><div class="ttname"><a href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a></div><div class="ttdeci">uint64_t haddr_t</div><div class="ttdef"><b>Definition</b> H5public.h:372</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga43a733fe9723dd15f5ad7abda909a1b8"><div class="ttname"><a href="group___f_a_p_l.html#ga43a733fe9723dd15f5ad7abda909a1b8">H5Pget_driver</a></div><div class="ttdeci">hid_t H5Pget_driver(hid_t plist_id)</div><div class="ttdoc">Returns low-lever driver identifier.</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga9195cb7b6c33ed8947486669702a4375"><div class="ttname"><a href="group___f_a_p_l.html#ga9195cb7b6c33ed8947486669702a4375">H5Pget_fapl_family</a></div><div class="ttdeci">herr_t H5Pget_fapl_family(hid_t fapl_id, hsize_t *memb_size, hid_t *memb_fapl_id)</div><div class="ttdoc">Returns file access property list information.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_use_per"></a>
Performing I/O</h2>
<p>The <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> and <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> functions transfer data between application memory and the file. They both take an optional data transfer property list which has some general driver-independent properties and optional driver-defined properties. An application will typically perform I/O in one of three styles via the <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> or <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> function:</p>
<p>Like file access properties in the previous section, data transfer properties can be set using a driver initialization function or a general purpose function. For example, to set the MPI-IO driver to use independent access for I/O operations one would say: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> dxpl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a>(H5P_DATA_XFER);</div>
<div class="line"><a class="code hl_function" href="group___d_x_p_l.html#ga22837d8504dc1f87f175b46b348ce0e5">H5Pset_dxpl_mpio</a>(dxpl, <a class="code hl_enumvalue" href="_h5_f_dmpi_8h.html#a99bc5a964089fea144e7056b004bcc16a6c67820a8798cd75a6f0ebbb44e9a2af">H5FD_MPIO_INDEPENDENT</a>);</div>
<div class="line"><a class="code hl_function" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c">H5Dread</a>(dataset, type, mspace, fspace, buffer, dxpl);</div>
<div class="line"><a class="code hl_function" href="group___p_l_c_r.html#ga5dce61149211d3ef319452aa598887fb">H5Pclose</a>(dxpl);</div>
<div class="ttc" id="a_h5_f_dmpi_8h_html_a99bc5a964089fea144e7056b004bcc16a6c67820a8798cd75a6f0ebbb44e9a2af"><div class="ttname"><a href="_h5_f_dmpi_8h.html#a99bc5a964089fea144e7056b004bcc16a6c67820a8798cd75a6f0ebbb44e9a2af">H5FD_MPIO_INDEPENDENT</a></div><div class="ttdeci">@ H5FD_MPIO_INDEPENDENT</div><div class="ttdef"><b>Definition</b> H5FDmpi.h:37</div></div>
<div class="ttc" id="agroup___d_x_p_l_html_ga22837d8504dc1f87f175b46b348ce0e5"><div class="ttname"><a href="group___d_x_p_l.html#ga22837d8504dc1f87f175b46b348ce0e5">H5Pset_dxpl_mpio</a></div><div class="ttdeci">herr_t H5Pset_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t xfer_mode)</div><div class="ttdoc">Sets data transfer mode.</div></div>
<div class="ttc" id="agroup___h5_d_html_ga8287d5a7be7b8e55ffeff68f7d26811c"><div class="ttname"><a href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c">H5Dread</a></div><div class="ttdeci">herr_t H5Dread(hid_t dset_id, hid_t mem_type_id, hid_t mem_space_id, hid_t file_space_id, hid_t dxpl_id, void *buf)</div><div class="ttdoc">Reads raw data from a dataset into a provided buffer.</div></div>
</div><!-- fragment --><p>The alternative is to initialize a driver defined C struct and pass it to the <a class="el" href="group___f_a_p_l.html#ga8bcce60e23e9d2a019212c63b146502e" title="Sets a file driver.">H5Pset_driver</a> function: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> dxpl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a>(H5P_DATA_XFER);</div>
<div class="line"><span class="keyword">static</span> H5FD_mpio_dxpl_t dx = {<a class="code hl_enumvalue" href="_h5_f_dmpi_8h.html#a99bc5a964089fea144e7056b004bcc16a6c67820a8798cd75a6f0ebbb44e9a2af">H5FD_MPIO_INDEPENDENT</a>};</div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga8bcce60e23e9d2a019212c63b146502e">H5Pset_driver</a>(dxpl, <a class="code hl_define" href="_h5_f_dmpio_8h.html#a7a231bc1d78744088a4e1d297284cabf">H5FD_MPIO</a>, &amp;dx);</div>
<div class="line"><a class="code hl_function" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c">H5Dread</a>(dataset, type, mspace, fspace, buffer, dxpl);</div>
<div class="ttc" id="a_h5_f_dmpio_8h_html_a7a231bc1d78744088a4e1d297284cabf"><div class="ttname"><a href="_h5_f_dmpio_8h.html#a7a231bc1d78744088a4e1d297284cabf">H5FD_MPIO</a></div><div class="ttdeci">#define H5FD_MPIO</div><div class="ttdef"><b>Definition</b> H5FDmpio.h:25</div></div>
</div><!-- fragment --><p>The transfer property list can be queried in a manner similar to the file access property list: the driver provides a function (or functions) to return various information about the transfer property list: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> driver = <a class="code hl_function" href="group___f_a_p_l.html#ga43a733fe9723dd15f5ad7abda909a1b8">H5Pget_driver</a>(dxpl);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_f_dmpio_8h.html#a7a231bc1d78744088a4e1d297284cabf">H5FD_MPIO</a>==driver) {</div>
<div class="line">    <a class="code hl_enumeration" href="_h5_f_dmpi_8h.html#a99bc5a964089fea144e7056b004bcc16">H5FD_mpio_xfer_t</a> xfer_mode;</div>
<div class="line">    <a class="code hl_function" href="group___d_x_p_l.html#ga3f1295b2ee6dcb59288ac885c5562aa8">H5Pget_dxpl_mpio</a>(dxpl, &amp;xfer_mode);</div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    ....</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dmpi_8h_html_a99bc5a964089fea144e7056b004bcc16"><div class="ttname"><a href="_h5_f_dmpi_8h.html#a99bc5a964089fea144e7056b004bcc16">H5FD_mpio_xfer_t</a></div><div class="ttdeci">H5FD_mpio_xfer_t</div><div class="ttdef"><b>Definition</b> H5FDmpi.h:36</div></div>
<div class="ttc" id="agroup___d_x_p_l_html_ga3f1295b2ee6dcb59288ac885c5562aa8"><div class="ttname"><a href="group___d_x_p_l.html#ga3f1295b2ee6dcb59288ac885c5562aa8">H5Pget_dxpl_mpio</a></div><div class="ttdeci">herr_t H5Pget_dxpl_mpio(hid_t dxpl_id, H5FD_mpio_xfer_t *xfer_mode)</div><div class="ttdoc">Returns the data transfer mode.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_use_inter"></a>
File Driver Interchangeability</h2>
<p>The HDF5 specifications describe two things: the mapping of data onto a linear format address space and the C API which performs the mapping. However, the mapping of the format address space onto storage intentionally falls outside the scope of the HDF5 specs. This is a direct result of the fact that it is not generally possible to store information about how to access storage inside the storage itself. For instance, given only the file name '/arborea/1225/work/f%03d' the HDF5 library is unable to tell whether the name refers to a file on the local file system, a family of files on the local file system, a file on host 'arborea' port 1225, a family of files on a remote system, etc.</p>
<p>Two ways which library could figure out where the storage is located are: storage access information can be provided by the user, or the library can try all known file access methods. This implementation uses the former method.</p>
<p>In general, if a file was created with one driver then it isn't possible to open it with another driver. There are of course exceptions: a file created with MPIO could probably be opened with the sec2 driver, any file created by the sec2 driver could be opened as a family of files with one member, etc. In fact, sometimes a file must not only be opened with the same driver but also with the same driver properties. The predefined drivers are written in such a way that specifying the correct driver is sufficient for opening a file.</p>
<h1><a class="anchor" id="sec_vfl_imp"></a>
Implementation of a Driver</h1>
<p>A driver is simply a collection of functions and data structures which are registered with the HDF5 library at runtime. The functions fall into these categories: </p><ul>
<li>Functions which operate on modes </li>
<li>Functions which operate on files </li>
<li>Functions which operate on the address space </li>
<li>Functions which operate on data </li>
<li>Functions for driver initialization </li>
<li>Optimization functions</li>
</ul>
<h2><a class="anchor" id="subsec_vfl_imp_mode"></a>
Mode Functions</h2>
<p>Some drivers need information about file access and data transfers which are very specific to the driver. The information is usually implemented as a pair of pointers to C structs which are allocated and initialized as part of an HDF5 property list and passed down to various driver functions. There are two classes of settings: file access modes that describe how to access the file through the driver, and data transfer modes which are settings that control I/O operations. Each file opened by a particular driver may have a different access mode; each dataset I/O request for a particular file may have a different data transfer mode.</p>
<p>Since each driver has its own particular requirements for various settings, each driver is responsible for defining the mode structures that it needs. Higher layers of the library treat the structures as opaque but must be able to copy and free them. Thus, the driver provides either the size of the structure or a pair of function pointers for each of the mode types.</p>
<p>Example: The family driver needs to know how the format address space is partitioned and the file access property list to use for the family members. </p><div class="fragment"><div class="line"><span class="comment">// Driver-specific file access properties</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5FD_family_fapl_t {</div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a>     memb_size;      <span class="comment">// size of each family member</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a>       memb_fapl;      <span class="comment">// file access property list for each family member</span></div>
<div class="line">} H5FD_family_fapl_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Driver specific data transfer properties</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5FD_family_dxpl_t {</div>
<div class="line">    <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a>       memb_dxpl_id;   <span class="comment">//data xfer property list of each member</span></div>
<div class="line">} H5FD_family_dxpl_t;</div>
<div class="ttc" id="a_h5public_8h_html_a7f81cce70fb546af88da24d9285d3c1c"><div class="ttname"><a href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a></div><div class="ttdeci">uint64_t hsize_t</div><div class="ttdef"><b>Definition</b> H5public.h:321</div></div>
</div><!-- fragment --><p> n order to copy or free one of these structures the member file access or data transfer properties must also be copied or freed. This is done by providing a copy and close function for each structure:</p>
<p>Example: The file access property list copy and close functions for the family driver: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *</div>
<div class="line">H5FD_family_fapl_copy(<span class="keyword">const</span> <span class="keywordtype">void</span> *_old_fa)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> H5FD_family_fapl_t *old_fa = (<span class="keyword">const</span> H5FD_family_fapl_t*)_old_fa;</div>
<div class="line">    H5FD_family_fapl_t *new_fa = malloc(<span class="keyword">sizeof</span>(H5FD_family_fapl_t));</div>
<div class="line">    assert(new_fa);</div>
<div class="line"> </div>
<div class="line">    memcpy(new_fa, old_fa, <span class="keyword">sizeof</span>(H5FD_family_fapl_t));</div>
<div class="line">    new_fa-&gt;memb_fapl_id = <a class="code hl_function" href="group___p_l_c_r.html#gad2663ccbcbf76b96cde4c104588ae21b">H5Pcopy</a>(old_fa-&gt;memb_fapl_id);</div>
<div class="line">    <span class="keywordflow">return</span> new_fa;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div>
<div class="line">H5FD_family_fapl_free(<span class="keywordtype">void</span> *_fa)</div>
<div class="line">{</div>
<div class="line">    H5FD_family_fapl_t  *fa = (H5FD_family_fapl_t*)_fa;</div>
<div class="line">    <a class="code hl_function" href="group___p_l_c_r.html#ga5dce61149211d3ef319452aa598887fb">H5Pclose</a>(fa-&gt;memb_fapl_id);</div>
<div class="line">    free(fa);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5public_8h_html_a3b079ecf932a5c599499cf7e298af160"><div class="ttname"><a href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div><div class="ttdeci">int herr_t</div><div class="ttdef"><b>Definition</b> H5public.h:269</div></div>
<div class="ttc" id="agroup___p_l_c_r_html_gad2663ccbcbf76b96cde4c104588ae21b"><div class="ttname"><a href="group___p_l_c_r.html#gad2663ccbcbf76b96cde4c104588ae21b">H5Pcopy</a></div><div class="ttdeci">hid_t H5Pcopy(hid_t plist_id)</div><div class="ttdoc">Copies an existing property list to create a new property list.</div></div>
</div><!-- fragment --><p>Generally when a file is created or opened the file access properties for the driver are copied into the file pointer which is returned and they may be modified from their original value (for instance, the file family driver modifies the member size property when opening an existing family). In order to support the <a class="el" href="group___h5_f.html#ga359585c49f82f5199178777b39e780f4" title="Returns a file access property list identifier.">H5Fget_access_plist</a> function the driver must provide a fapl_get callback which creates a copy of the driver-specific properties based on a particular file.</p>
<p>Example: The file family driver copies the member size file access property list into the return value: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *</div>
<div class="line">H5FD_family_fapl_get(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file)</div>
<div class="line">{</div>
<div class="line">    H5FD_family_t   *file = (H5FD_family_t*)_file;</div>
<div class="line">    H5FD_family_fapl_t  *fa = calloc(1, <span class="keyword">sizeof</span>(H5FD_family_fapl_t*));</div>
<div class="line"> </div>
<div class="line">    fa-&gt;memb_size = file-&gt;memb_size;</div>
<div class="line">    fa-&gt;memb_fapl_id = <a class="code hl_function" href="group___p_l_c_r.html#gad2663ccbcbf76b96cde4c104588ae21b">H5Pcopy</a>(file-&gt;memb_fapl_id);</div>
<div class="line">    <span class="keywordflow">return</span> fa;</div>
<div class="line">}</div>
<div class="ttc" id="astruct_h5_f_d__t_html"><div class="ttname"><a href="struct_h5_f_d__t.html">H5FD_t</a></div><div class="ttdef"><b>Definition</b> H5FDdevelop.h:340</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_imp_file"></a>
File Functions</h2>
<p>The higher layers of the library expect files to have a name and allow the file to be accessed in various modes. The driver must be able to create a new file, replace an existing file, or open an existing file. Opening or creating a file should return a handle, a pointer to a specialization of the <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> struct, which allows read-only or read-write access and which will be passed to the other driver functions as they are called.(Read-only access is only appropriate when opening an existing file.) </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    <span class="comment">// Public fields</span></div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__class__t.html">H5FD_class_t</a> *cls; <span class="comment">//class data defined below</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Private fields -- driver-defined</span></div>
<div class="line"> </div>
<div class="line">} <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a>;</div>
<div class="ttc" id="astruct_h5_f_d__class__t_html"><div class="ttname"><a href="struct_h5_f_d__class__t.html">H5FD_class_t</a></div><div class="ttdef"><b>Definition</b> H5FDdevelop.h:199</div></div>
</div><!-- fragment --><p>Example: The family driver requires handles to the underlying storage, the size of the members for this particular file (which might be different than the member size specified in the file access property list if an existing file family is being opened), the name used to open the file in case additional members must be created, and the flags to use for creating those additional members. The eoa member caches the size of the format address space so the family members don't have to be queried in order to find it. </p><div class="fragment"><div class="line"><span class="comment">// The description of a file belonging to this driver.</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5FD_family_t {</div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a>      pub;            <span class="comment">// public stuff, must be first</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a>       memb_fapl_id;   <span class="comment">// file access property list for members</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a>     memb_size;      <span class="comment">// maximum size of each member file</span></div>
<div class="line">    <span class="keywordtype">int</span>         nmembs;         <span class="comment">// number of family members</span></div>
<div class="line">    <span class="keywordtype">int</span>         amembs;         <span class="comment">// number of member slots allocated</span></div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a>      **memb;         <span class="comment">// dynamic array of member pointers</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a>     eoa;            <span class="comment">// end of allocated addresses</span></div>
<div class="line">    <span class="keywordtype">char</span>        *name;          <span class="comment">// name generator printf format</span></div>
<div class="line">    <span class="keywordtype">unsigned</span>    flags;          <span class="comment">// flags for opening additional members</span></div>
<div class="line">} H5FD_family_t;</div>
</div><!-- fragment --><p>Example: The sec2 driver needs to keep track of the underlying Unix file descriptor and also the end of format address space and current Unix file size. It also keeps track of the current file position and last operation (read, write, or unknown) in order to optimize calls to lseek. The device and inode fields are defined on Unix in order to uniquely identify the file and will be discussed below. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>H5FD_sec2_t {</div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a>      pub;                    <span class="comment">// public stuff, must be first</span></div>
<div class="line">    <span class="keywordtype">int</span>         fd;                     <span class="comment">// the unix file</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a>     eoa;                    <span class="comment">// end of allocated region</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a>     eof;                    <span class="comment">// end of file; current file size</span></div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a>     pos;                    <span class="comment">// current file I/O position</span></div>
<div class="line">    <span class="keywordtype">int</span>         op;                     <span class="comment">// last operation</span></div>
<div class="line">    dev_t       device;                 <span class="comment">// file device number</span></div>
<div class="line">    ino_t       inode;                  <span class="comment">// file i-node number</span></div>
<div class="line">} H5FD_sec2_t;</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_imp_open"></a>
Open Files</h2>
<p>All drivers must define a function for opening/creating a file. This function should have a prototype which is: </p><table class="doxtable">
<tr>
<td><code>static <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> * open (const char *name, unsigned flags, hid_t fapl, haddr_t maxaddr)</code> </td><td>The file name name and file access property list fapl are the same as were specified in the <a class="el" href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4" title="Creates an HDF5 file.">H5Fcreate</a> or <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call. The flags are the same as in those calls also except the flag <a class="el" href="_h5_fpublic_8h.html#a5f311bcbc21086812e8b754f6354262b">H5F_ACC_CREAT</a> is also present if the call was to H5Fcreate and they are documented in the '<a class="el" href="_h5_fpublic_8h.html">H5Fpublic.h</a>' file. The maxaddr argument is the maximum format address that the driver should be prepared to handle (the minimum address is always zero).  </td></tr>
</table>
<p>Example: The sec2 driver opens a Unix file with the requested name and saves information which uniquely identifies the file (the Unix device number and inode). </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *</div>
<div class="line">H5FD_sec2_open(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">unsigned</span> flags, <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl_id<span class="comment">/*unused*/</span>,</div>
<div class="line">               <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a> maxaddr)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span>    o_flags;</div>
<div class="line">    <span class="keywordtype">int</span>         fd;</div>
<div class="line">    <span class="keyword">struct </span>stat sb;</div>
<div class="line">    H5FD_sec2_t *file=NULL;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check arguments</span></div>
<div class="line">    <span class="keywordflow">if</span> (!name || !*name) <span class="keywordflow">return</span> NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (0==maxaddr || <a class="code hl_define" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a>==maxaddr) <span class="keywordflow">return</span> NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (ADDR_OVERFLOW(maxaddr)) <span class="keywordflow">return</span> NULL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Build the open flags</span></div>
<div class="line">    o_flags = (<a class="code hl_define" href="_h5_fpublic_8h.html#a402673dec5c537b27a49a9a8bd6140b4">H5F_ACC_RDWR</a> &amp; flags) ? O_RDWR : O_RDONLY;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_fpublic_8h.html#a5a2d6726f9ad8d2bca8df2b817e5ad6a">H5F_ACC_TRUNC</a> &amp; flags) o_flags |= O_TRUNC;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_fpublic_8h.html#a5f311bcbc21086812e8b754f6354262b">H5F_ACC_CREAT</a> &amp; flags) o_flags |= O_CREAT;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_define" href="_h5_fpublic_8h.html#a7a47250dc1435705233dca7297ba3d90">H5F_ACC_EXCL</a> &amp; flags) o_flags |= O_EXCL;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Open the file</span></div>
<div class="line">    <span class="keywordflow">if</span> ((fd=open(name, o_flags, 0666))&lt;0) <span class="keywordflow">return</span> NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (fstat(fd, &amp;sb)&lt;0) {</div>
<div class="line">        close(fd);</div>
<div class="line">        <span class="keywordflow">return</span> NULL;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create the new file struct</span></div>
<div class="line">    file = calloc(1, <span class="keyword">sizeof</span>(H5FD_sec2_t));</div>
<div class="line">    file-&gt;fd = fd;</div>
<div class="line">    file-&gt;eof = sb.st_size;</div>
<div class="line">    file-&gt;pos = <a class="code hl_define" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a>;</div>
<div class="line">    file-&gt;op = <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a3070ec4253e2531351d7aeb586069a54">OP_UNKNOWN</a>;</div>
<div class="line">    file-&gt;device = sb.st_dev;</div>
<div class="line">    file-&gt;inode = sb.st_ino;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a>*)file;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dprivate_8h_html_ad04fbad2016010f126b7e16230011628a3070ec4253e2531351d7aeb586069a54"><div class="ttname"><a href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a3070ec4253e2531351d7aeb586069a54">OP_UNKNOWN</a></div><div class="ttdeci">@ OP_UNKNOWN</div><div class="ttdef"><b>Definition</b> H5FDprivate.h:52</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a402673dec5c537b27a49a9a8bd6140b4"><div class="ttname"><a href="_h5_fpublic_8h.html#a402673dec5c537b27a49a9a8bd6140b4">H5F_ACC_RDWR</a></div><div class="ttdeci">#define H5F_ACC_RDWR</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:29</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a5f311bcbc21086812e8b754f6354262b"><div class="ttname"><a href="_h5_fpublic_8h.html#a5f311bcbc21086812e8b754f6354262b">H5F_ACC_CREAT</a></div><div class="ttdeci">#define H5F_ACC_CREAT</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:33</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a7a47250dc1435705233dca7297ba3d90"><div class="ttname"><a href="_h5_fpublic_8h.html#a7a47250dc1435705233dca7297ba3d90">H5F_ACC_EXCL</a></div><div class="ttdeci">#define H5F_ACC_EXCL</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:31</div></div>
<div class="ttc" id="a_h5public_8h_html_a676244a60b85ee8bbd111afd4a8fce3c"><div class="ttname"><a href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a></div><div class="ttdeci">#define HADDR_UNDEF</div><div class="ttdef"><b>Definition</b> H5public.h:384</div></div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_imp_close"></a>
Closing Files</h2>
<p>Closing a file simply means that all cached data should be flushed to the next lower layer, the file should be closed at the next lower layer, and all file-related data structures should be freed. All information needed by the close function is already present in the file handle. </p><table class="doxtable">
<tr>
<td><code>static herr_t close (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>The file argument is the handle which was returned by the open function, and the close should free only memory associated with the driver-specific part of the handle (the public parts will have already been released by HDF5's virtual file layer).  </td></tr>
</table>
<p>Example: The sec2 driver just closes the underlying Unix file, making sure that the actual file size is the same as that known to the library by writing a zero to the last file position it hasn't been written by some previous operation (which happens in the same code which flushes the file contents and is shown below). </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div>
<div class="line">H5FD_sec2_close(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file)</div>
<div class="line">{</div>
<div class="line">    H5FD_sec2_t *file = (H5FD_sec2_t*)_file;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (H5FD_sec2_flush(_file)&lt;0) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (close(file-&gt;fd)&lt;0) <span class="keywordflow">return</span> -1;</div>
<div class="line">    free(file);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_imp_key"></a>
File Keys</h2>
<p>Occasionally an application will attempt to open a single file more than one time in order to obtain multiple handles to the file. HDF5 allows the files to share information(For instance, writing data to one handle will cause the data to be immediately visible on the other handle.) but in order to accomplish this HDF5 must be able to tell when two names refer to the same file. It does this by associating a driver-defined key with each file opened by a driver and comparing the key for an open request with the keys for all other files currently open by the same driver. </p><table class="doxtable">
<tr>
<td><code>const int cmp (const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *f1, const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *f2)</code> </td><td>The driver may provide a function which compares two files f1 and f2 belonging to the same driver and returns a negative, positive, or zero value a la the strcmp function.(The ordering is arbitrary as long as it's consistent within a particular file driver.) If this function is not provided then HDF5 assumes that all calls to the open callback return unique files regardless of the arguments and it is up to the application to avoid doing this if that assumption is incorrect.  </td></tr>
</table>
<p>Each time a file is opened the library calls the cmp function to compare that file with all other files currently open by the same driver and if one of them matches (at most one can match) then the file which was just opened is closed and the previously opened file is used instead.</p>
<p>Opening a file twice with incompatible flags will result in failure. For instance, opening a file with the truncate flag is a two step process which first opens the file without truncation so keys can be compared, and if no matching file is found already open then the file is closed and immediately reopened with the truncation flag set (if a matching file is already open then the truncating open will fail).</p>
<p>Example: The sec2 driver uses the Unix device and i-node as the key. They were initialized when the file was opened. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span></div>
<div class="line">H5FD_sec2_cmp(<span class="keyword">const</span> <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_f1, <span class="keyword">const</span> <a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_f2)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> H5FD_sec2_t   *f1 = (<span class="keyword">const</span> H5FD_sec2_t*)_f1;</div>
<div class="line">    <span class="keyword">const</span> H5FD_sec2_t   *f2 = (<span class="keyword">const</span> H5FD_sec2_t*)_f2;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (f1-&gt;device &lt; f2-&gt;device) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (f1-&gt;device &gt; f2-&gt;device) <span class="keywordflow">return</span> 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (f1-&gt;inode &lt; f2-&gt;inode) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (f1-&gt;inode &gt; f2-&gt;inode) <span class="keywordflow">return</span> 1;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subsec_vfl_imp_save"></a>
Saving Modes Across Opens</h2>
<p>Some drivers may also need to store certain information in the file superblock in order to be able to reliably open the file at a later date. This is done by three functions: one to determine how much space will be necessary to store the information in the superblock, one to encode the information, and one to decode the information. These functions are optional, but if any one is defined then the other two must also be defined. </p><table class="doxtable">
<tr>
<th>Function </th><th>Description  </th></tr>
<tr>
<td><code>static hsize_t sb_size (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>The sb_size function returns the number of bytes necessary to encode information needed later if the file is reopened.  </td></tr>
<tr>
<td><code>static herr_t sb_encode (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, char *name, unsigned char *buf)</code> </td><td>The sb_encode function encodes information from the file into buffer buf allocated by the caller. It also writes an 8-character (plus null termination) into the name argument, which should be a unique identification for the driver.  </td></tr>
<tr>
<td><code>static herr_t sb_decode (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, const char *name, const unsigned char *buf)</code> </td><td>The sb_decode function looks at the name decodes data from the buffer buf and updates the file argument with the new information, advancing *p in the process.  </td></tr>
</table>
<p>The part of this which is somewhat tricky is that the file must be readable before the superblock information is decoded. File access modes fall outside the scope of the HDF5 file format, but they are placed inside the boot block for convenience.(File access modes do not describe data, but rather describe how the HDF5 format address space is mapped to the underlying file(s). Thus, in general the mapping must be known before the file superblock can be read. However, the user usually knows enough about the mapping for the superblock to be readable and once the superblock is read the library can fill in the missing parts of the mapping.)</p>
<h1><a class="anchor" id="sec_vfl_address"></a>
Address Space Functions</h1>
<p>HDF5 does not assume that a file is a linear address space of bytes. Instead, the library will call functions to allocate and free portions of the HDF5 format address space, which in turn map onto functions in the file driver to allocate and free portions of file address space. The library tells the file driver how much format address space it wants to allocate and the driver decides what format address to use and how that format address is mapped onto the file address space. Usually the format address is chosen so that the file address can be calculated in constant time for data I/O operations (which are always specified by format addresses).</p>
<h2><a class="anchor" id="subsec_vfl_address_blk"></a>
Userblock and Superblock</h2>
<p>The HDF5 format allows an optional userblock to appear before the actual HDF5 data in such a way that if the userblock is sucked out of the file and everything remaining is shifted downward in the file address space, then the file is still a valid HDF5 file. The userblock size can be zero or any multiple of two greater than or equal to 512 and the file superblock begins immediately after the userblock.</p>
<p>HDF5 allocates space for the userblock and superblock by calling an allocation function defined below, which must return a chunk of memory at format address zero on the first call.</p>
<h2><a class="anchor" id="subsec_vfl_address_alloc"></a>
Allocatiion of Format Regions</h2>
<p>The library makes many types of allocation requests: </p><table class="doxtable">
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ae536846ac8d6ecd1a2a8479409df1bce">H5FD_MEM_SUPER</a></td><td>userblock  </td></tr>
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a29b8528e16990fbe265682559b917fa3">H5FD_MEM_BTREE</a></td><td>An allocation request for a node of a B-tree.   </td></tr>
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ab435b061fede0393691acbe7cac2cb2e">H5FD_MEM_DRAW</a></td><td>An allocation request for the raw data of a dataset.   </td></tr>
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a020d6245f874e8262058c3278fefe58e">H5FD_MEM_GHEAP</a></td><td>An allocation request for a global heap collection. Global heaps are used to store certain types of references such as dataset region references. The set of all global heap collections can become quite large.   </td></tr>
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ae7536174d3ae2a842a71d6c192b43a13">H5FD_MEM_LHEAP</a></td><td>An allocation request for a local heap. Local heaps are used to store the names which are members of a group. The combined size of all local heaps is a function of the number of object names in the file.   </td></tr>
<tr>
<td><a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a4337f7056fb57717e82fa1081f496d75">H5FD_MEM_OHDR</a></td><td>An allocation request for (part of) an object header. Object headers are relatively small and include meta information about objects (like the data space and type of a dataset) and attributes.   </td></tr>
</table>
<p>When a chunk of memory is freed the library adds it to a free list and allocation requests are satisfied from the free list before requesting memory from the file driver. Each type of allocation request enumerated above has its own free list, but the file driver can specify that certain object types can share a free list. It does so by providing an array which maps a request type to a free list. If any value of the map is H5MF_DEFAULT (zero) then the object's own free list is used. The special value H5MF_NOLIST indicates that the library should not attempt to maintain a free list for that particular object type, instead calling the file driver each time an object of that type is freed.</p>
<p>Mappings predefined in the '<a class="el" href="_h5_f_ddevelop_8h.html">H5FDdevelop.h</a>' file are: </p><table class="doxtable">
<tr>
<td><a class="el" href="_h5_f_ddevelop_8h.html#a4c63846487a43d7a3d589ac2852c9078">H5FD_FLMAP_SINGLE</a></td><td>All memory usage types are mapped to a single free list.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_ddevelop_8h.html#ac828cc26131c2df37fdb84ca13272540">H5FD_FLMAP_DICHOTOMY</a></td><td>Memory usage is segregated into meta data and raw data for the purposes of memory management.   </td></tr>
<tr>
<td><a class="el" href="_h5_f_ddevelop_8h.html#a49f2128fbc831c73ec19f7e24ec6ee24">H5FD_FLMAP_DEFAULT</a></td><td>Each memory usage type has its own free list.   </td></tr>
</table>
<p>Example: To make a map that manages object headers on one free list and everything else on another free list one might initialize the map with the following code: (the use of <a class="el" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ae536846ac8d6ecd1a2a8479409df1bce">H5FD_MEM_SUPER</a> is arbitrary) </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_f_dpublic_8h.html#a02887a6f018be1a0ce7358522095578b">H5FD_mem_t</a> mt, map[<a class="code hl_enumvalue" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a3be201777da432df4a8e2c1b618a7566">H5FD_MEM_NTYPES</a>];</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (mt = 0; mt &lt; <a class="code hl_enumvalue" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a3be201777da432df4a8e2c1b618a7566">H5FD_MEM_NTYPES</a>; mt++) {</div>
<div class="line">    map[mt] = (<a class="code hl_enumvalue" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a4337f7056fb57717e82fa1081f496d75">H5FD_MEM_OHDR</a>==  mt) ? mt : <a class="code hl_enumvalue" href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ae536846ac8d6ecd1a2a8479409df1bce">H5FD_MEM_SUPER</a>;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_a02887a6f018be1a0ce7358522095578b"><div class="ttname"><a href="_h5_f_dpublic_8h.html#a02887a6f018be1a0ce7358522095578b">H5FD_mem_t</a></div><div class="ttdeci">enum H5F_mem_t H5FD_mem_t</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:273</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a51e588cd954ea2388816bd0818850eb5a3be201777da432df4a8e2c1b618a7566"><div class="ttname"><a href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a3be201777da432df4a8e2c1b618a7566">H5FD_MEM_NTYPES</a></div><div class="ttdeci">@ H5FD_MEM_NTYPES</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:163</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a51e588cd954ea2388816bd0818850eb5a4337f7056fb57717e82fa1081f496d75"><div class="ttname"><a href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5a4337f7056fb57717e82fa1081f496d75">H5FD_MEM_OHDR</a></div><div class="ttdeci">@ H5FD_MEM_OHDR</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:161</div></div>
<div class="ttc" id="a_h5_fpublic_8h_html_a51e588cd954ea2388816bd0818850eb5ae536846ac8d6ecd1a2a8479409df1bce"><div class="ttname"><a href="_h5_fpublic_8h.html#a51e588cd954ea2388816bd0818850eb5ae536846ac8d6ecd1a2a8479409df1bce">H5FD_MEM_SUPER</a></div><div class="ttdeci">@ H5FD_MEM_SUPER</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:156</div></div>
</div><!-- fragment --><p>If an allocation request cannot be satisfied from the free list then one of two things happen. If the driver defines an allocation callback then it is used to allocate space; otherwise new memory is allocated from the end of the format address space by incrementing the end-of-address marker. </p><table class="doxtable">
<tr>
<td><code>static haddr_t alloc (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5MF_type_t type, hsize_t size)</code> </td><td>The file argument is the file from which space is to be allocated, type is the type of memory being requested (from the list above) without being mapped according to the freelist map and size is the number of bytes being requested. The library is allowed to allocate large chunks of storage and manage them in a layer above the file driver (although the current library doesn't do that). The allocation function should return a format address for the first byte allocated. The allocated region extends from that address for size bytes. If the request cannot be honored then the undefined address value is returned (<a class="el" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a>). The first call to this function for a file which has never had memory allocated must return a format address of zero or <a class="el" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a> since this is how the library allocates space for the userblock and/or superblock.  </td></tr>
</table>
<h2><a class="anchor" id="subsec_vfl_address_free"></a>
Freeing Format Regions</h2>
<p>When the library is finished using a certain region of the format address space it will return the space to the free list according to the type of memory being freed and the free list map described above. If the free list has been disabled for a particular memory usage type (according to the free list map) and the driver defines a free callback then it will be invoked. The free callback is also invoked for all entries on the free list when the file is closed.</p>
<table class="doxtable">
<tr>
<td><code>static herr_t free (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5MF_type_t type, haddr_t addr, hsize_t size)</code> </td><td>The file argument is the file for which space is being freed; type is the type of object being freed (from the list above) without being mapped according to the freelist map; addr is the first format address to free; and size is the size in bytes of the region being freed. The region being freed may refer to just part of the region originally allocated and/or may cross allocation boundaries provided all regions being freed have the same usage type. However, the library will never attempt to free regions which have already been freed or which have never been allocated.  </td></tr>
</table>
<p>A driver may choose to not define the free function, in which case format addresses will be leaked. This isn't normally a huge problem since the library contains a simple free list of its own and freeing parts of the format address space is not a common occurrence.</p>
<h2><a class="anchor" id="subsec_vfl_address_query"></a>
Querying the Address Range</h2>
<p>Each file driver must have some mechanism for setting and querying the end of address, or EOA, marker. The EOA marker is the first format address after the last format address ever allocated. If the last part of the allocated address range is freed then the driver may optionally decrease the eoa marker. </p><table class="doxtable">
<tr>
<td><code>static haddr_t get_eoa (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>This function returns the current value of the EOA marker for the specified file.  </td></tr>
</table>
<p>Example: The sec2 driver just returns the current eoa marker value which is cached in the file structure: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a></div>
<div class="line">H5FD_sec2_get_eoa(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file)</div>
<div class="line">{</div>
<div class="line">    H5FD_sec2_t *file = (H5FD_sec2_t*)_file;</div>
<div class="line">    <span class="keywordflow">return</span> file-&gt;eoa;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The eoa marker is initially zero when a file is opened and the library may set it to some other value shortly after the file is opened (after the superblock is read and the saved eoa marker is determined) or when allocating additional memory in the absence of an alloc callback (described above).</p>
<p>Example: The sec2 driver simply caches the eoa marker in the file structure and does not extend the underlying Unix file. When the file is flushed or closed then the Unix file size is extended to match the eoa marker. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div>
<div class="line">H5FD_sec2_set_eoa(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file, <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a> addr)</div>
<div class="line">{</div>
<div class="line">    H5FD_sec2_t *file = (H5FD_sec2_t*)_file;</div>
<div class="line">    file-&gt;eoa = addr;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_vfl_data"></a>
Data Functions</h1>
<p>These functions operate on data, transferring a region of the format address space between memory and files.</p>
<h2><a class="anchor" id="subsec_vfl_data_cont"></a>
Contiguous I/O Functions</h2>
<p>A driver must specify two functions to transfer data from the library to the file and vice versa. </p><table class="doxtable">
<tr>
<td><code>static herr_t read (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, hsize_t size, void *buf)</code> </td><td>The read function reads data from file beginning at address addr and continuing for size bytes into the buffer buf supplied by the caller.  </td></tr>
<tr>
<td><code>static herr_t write (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, hsize_t size, const void *buf)</code> </td><td>The write function transfers data in the opposite direction.  </td></tr>
</table>
<ul>
<li>Both functions take a data transfer property list dxpl which indicates the fine points of how the data is to be transferred and which comes directly from the <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> or <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> function. </li>
<li>Both functions receive type of data being written, which may allow a driver to tune it's behavior for different kinds of data. </li>
<li>Both functions should return a negative value if they fail to transfer the requested data, or non-negative if they succeed. The library will never attempt to read from unallocated regions of the format address space.</li>
</ul>
<p>Example: The sec2 driver just makes system calls. It tries not to call lseek if the current operation is the same as the previous operation and the file position is correct. It also fills the output buffer with zeros when reading between the current EOF and EOA markers and restarts system calls which were interrupted. </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div>
<div class="line">H5FD_sec2_read(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file, <a class="code hl_typedef" href="_h5_f_dpublic_8h.html#a02887a6f018be1a0ce7358522095578b">H5FD_mem_t</a> type<span class="comment">/*unused*/</span>, <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> dxpl_id<span class="comment">/*unused*/</span>,</div>
<div class="line">        <a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a> addr, <a class="code hl_typedef" href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a> size, <span class="keywordtype">void</span> *buf<span class="comment">/*out*/</span>)</div>
<div class="line">{</div>
<div class="line">    H5FD_sec2_t         *file = (H5FD_sec2_t*)_file;</div>
<div class="line">    ssize_t             nbytes;</div>
<div class="line">    </div>
<div class="line">    assert(file &amp;&amp; file-&gt;pub.cls);</div>
<div class="line">    assert(buf);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Check for overflow conditions */</span></div>
<div class="line">    <span class="keywordflow">if</span> (REGION_OVERFLOW(addr, size)) <span class="keywordflow">return</span> -1;</div>
<div class="line">    <span class="keywordflow">if</span> (addr+size&gt;file-&gt;eoa) <span class="keywordflow">return</span> -1;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* Seek to the correct location */</span></div>
<div class="line">    <span class="keywordflow">if</span> ((addr!=file-&gt;pos || <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628ac02b22f7017838ad0c1304b26a8cb2d2">OP_READ</a>!=file-&gt;op) &amp;&amp;</div>
<div class="line">        file_seek(file-&gt;fd, (file_offset_t)addr, SEEK_SET)&lt;0) {</div>
<div class="line">        file-&gt;pos = <a class="code hl_define" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a>;</div>
<div class="line">        file-&gt;op = <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a3070ec4253e2531351d7aeb586069a54">OP_UNKNOWN</a>;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/*</span></div>
<div class="line"><span class="comment">       Read data, being careful of interrupted system calls, partial results,</span></div>
<div class="line"><span class="comment">       and the end of the file.</span></div>
<div class="line"><span class="comment">      /</span></div>
<div class="line"><span class="comment">    while (size&gt;0) {</span></div>
<div class="line"><span class="comment">        do nbytes = read(file-&gt;fd, buf, size);</span></div>
<div class="line"><span class="comment">        while (-1==nbytes &amp;&amp; EINTR==errno);</span></div>
<div class="line"><span class="comment">        if (-1==nbytes) {</span></div>
<div class="line"><span class="comment">            /* error */</span></div>
<div class="line">            file-&gt;pos = <a class="code hl_define" href="_h5public_8h.html#a676244a60b85ee8bbd111afd4a8fce3c">HADDR_UNDEF</a>;</div>
<div class="line">            file-&gt;op = <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a3070ec4253e2531351d7aeb586069a54">OP_UNKNOWN</a>;</div>
<div class="line">            <span class="keywordflow">return</span> -1;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (0==nbytes) {</div>
<div class="line">            <span class="comment">/* end of file but not end of format address space */</span></div>
<div class="line">            memset(buf, 0, size);</div>
<div class="line">            size = 0;</div>
<div class="line">        }</div>
<div class="line">        assert(nbytes&gt;=0);</div>
<div class="line">        assert((<a class="code hl_typedef" href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a>)nbytes&lt;=size);</div>
<div class="line">        size -= (<a class="code hl_typedef" href="_h5public_8h.html#a7f81cce70fb546af88da24d9285d3c1c">hsize_t</a>)nbytes;</div>
<div class="line">        addr += (<a class="code hl_typedef" href="_h5public_8h.html#a8c86e866f40d7167cf9a1934c72b856f">haddr_t</a>)nbytes;</div>
<div class="line">        buf = (<span class="keywordtype">char</span>*)buf + nbytes;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Update current position */</span></div>
<div class="line">    file-&gt;pos = addr;</div>
<div class="line">    file-&gt;op = <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628ac02b22f7017838ad0c1304b26a8cb2d2">OP_READ</a>;</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dprivate_8h_html_ad04fbad2016010f126b7e16230011628ac02b22f7017838ad0c1304b26a8cb2d2"><div class="ttname"><a href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628ac02b22f7017838ad0c1304b26a8cb2d2">OP_READ</a></div><div class="ttdeci">@ OP_READ</div><div class="ttdef"><b>Definition</b> H5FDprivate.h:53</div></div>
</div><!-- fragment --><p> Example: The sec2 write callback is similar except it updates the file EOF marker when extending the file.</p>
<h2><a class="anchor" id="subsec_vfl_data_flush"></a>
Flushing Cached Data</h2>
<p>Some drivers may desire to cache data in memory in order to make larger I/O requests to the underlying file and thus improving bandwidth. Such drivers should register a cache flushing function so that the library can insure that data has been flushed out of the drivers in response to the application calling <a class="el" href="group___h5_f.html#gae686870f0a276c4d06bbc667b2c24124" title="Flushes all buffers associated with a file to storage.">H5Fflush</a>. </p><table class="doxtable">
<tr>
<td><code>static herr_t flush (<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>Flush all data for file file to storage.  </td></tr>
</table>
<p>Example: The sec2 driver doesn't cache any data but it also doesn't extend the Unix file as aggressively as it should. Therefore, when finalizing a file it should write a zero to the last byte of the allocated region so that when reopening the file later the EOF marker will be at least as large as the EOA marker saved in the superblock (otherwise HDF5 will refuse to open the file, claiming that the data appears to be truncated). </p><div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div>
<div class="line">H5FD_sec2_flush(<a class="code hl_struct" href="struct_h5_f_d__t.html">H5FD_t</a> *_file)</div>
<div class="line">{</div>
<div class="line">    H5FD_sec2_t *file = (H5FD_sec2_t*)_file;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (file-&gt;eoa&gt;file-&gt;eof) {</div>
<div class="line">        <span class="keywordflow">if</span> (-1==file_seek(file-&gt;fd, file-&gt;eoa-1, SEEK_SET)) <span class="keywordflow">return</span> -1;</div>
<div class="line">        <span class="keywordflow">if</span> (write(file-&gt;fd, <span class="stringliteral">&quot;&quot;</span>, 1)!=1) <span class="keywordflow">return</span> -1;</div>
<div class="line">        file-&gt;eof = file-&gt;eoa;</div>
<div class="line">        file-&gt;pos = file-&gt;eoa;</div>
<div class="line">        file-&gt;op = <a class="code hl_enumvalue" href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a17a60143bf77a229ec511cfe1465723e">OP_WRITE</a>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_dprivate_8h_html_ad04fbad2016010f126b7e16230011628a17a60143bf77a229ec511cfe1465723e"><div class="ttname"><a href="_h5_f_dprivate_8h.html#ad04fbad2016010f126b7e16230011628a17a60143bf77a229ec511cfe1465723e">OP_WRITE</a></div><div class="ttdeci">@ OP_WRITE</div><div class="ttdef"><b>Definition</b> H5FDprivate.h:54</div></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_vfl_opt"></a>
Optimization Functions</h1>
<p>The library is capable of performing several generic optimizations on I/O, but these types of optimizations may not be appropriate for a given VFL driver.</p>
<p>Each driver may provide a query function to allow the library to query whether to enable these optimizations. If a driver lacks a query function, the library will disable all types of optimizations which can be queried.</p>
<table class="doxtable">
<tr>
<td><code>static herr_t query (const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, unsigned long *flags)</code> </td><td>This function is called by the library to query which optimizations to enable for I/O to this driver.  </td></tr>
</table>
<p>These are the flags which are currently defined: </p><table class="doxtable">
<tr>
<td><code>H5FD_FEAT_AGGREGATE_METADATA (0x00000001)</code> </td><td>Defining the H5FD_FEAT_AGGREGATE_METADATA for a VFL driver means that the library will attempt to allocate a larger block for metadata and then sub-allocate each metadata request from that larger block.  </td></tr>
<tr>
<td><code>H5FD_FEAT_ACCUMULATE_METADATA (0x00000002)</code> </td><td>Defining the H5FD_FEAT_ACCUMULATE_METADATA for a VFL driver means that the library will attempt to cache metadata as it is written to the file and build up a larger block of metadata to eventually pass to the VFL 'write' routine.  </td></tr>
<tr>
<td><code>H5FD_FEAT_DATA_SIEVE (0x00000004)</code> </td><td>Defining the H5FD_FEAT_DATA_SIEVE for a VFL driver means that the library will attempt to cache raw data as it is read from/written to a file in a "data sieve" buffer.  </td></tr>
</table>
<p>See Rajeev Thakur's papers: <a href="https://web.cels.anl.gov/~thakur/papers/mpio-impl.pdf">https://web.cels.anl.gov/~thakur/papers/mpio-impl.pdf</a> <a href="https://web.cels.anl.gov/~thakur/papers/romio-coll.pdf">https://web.cels.anl.gov/~thakur/papers/romio-coll.pdf</a></p>
<h1><a class="anchor" id="sec_vfl_reg"></a>
Registration of a Driver</h1>
<p>Before a driver can be used the HDF5 library needs to be told of its existence. This is done by registering the driver, which results in a driver identification number. Instead of passing many arguments to the registration function, the driver information is entered into a structure and the address of the structure is passed to the registration function where it is copied. This allows the HDF5 API to be extended while providing backward compatibility at the source level.</p>
<table class="doxtable">
<tr>
<td><code>hid_t H5FDregister (<a class="el" href="struct_h5_f_d__class__t.html">H5FD_class_t</a> *cls)</code> </td><td>The driver described by struct cls is registered with the library and an ID number for the driver is returned.  </td></tr>
</table>
<p>The <a class="el" href="struct_h5_f_d__class__t.html">H5FD_class_t</a> type is a struct with the following fields: </p><table class="doxtable">
<tr>
<td><code>const char *name</code> </td><td>A pointer to a constant, null-terminated driver name to be used for debugging purposes.  </td></tr>
<tr>
<td><code>size_t fapl_size</code> </td><td>The size in bytes of the file access mode structure or zero if the driver supplies a copy function or doesn't define the structure.  </td></tr>
<tr>
<td><code>void *(*fapl_copy)(const void *fapl)</code> </td><td>An optional function which copies a driver-defined file access mode structure. This field takes precedence over fm_size when both are defined.  </td></tr>
<tr>
<td><code>void (*fapl_free)(void *fapl)</code> </td><td>An optional function to free the driver-defined file access mode structure. If null, then the library calls the C free function to free the structure.  </td></tr>
<tr>
<td><code>size_t dxpl_size</code> </td><td>The size in bytes of the data transfer mode structure or zero if the driver supplies a copy function or doesn't define the structure.  </td></tr>
<tr>
<td><code>void *(*dxpl_copy)(const void *dxpl)</code> </td><td>An optional function which copies a driver-defined data transfer mode structure. This field takes precedence over xm_size when both are defined.  </td></tr>
<tr>
<td><code>void (*dxpl_free)(void *dxpl)</code> </td><td>An optional function to free the driver-defined data transfer mode structure. If null, then the library calls the C free function to free the structure.  </td></tr>
<tr>
<td><code><a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *(*open)(const char *name, unsigned flags, hid_t fapl, haddr_t maxaddr)</code> </td><td>The function which opens or creates a new file.  </td></tr>
<tr>
<td><code>herr_t (*close)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>The function which ends access to a file.  </td></tr>
<tr>
<td><code>int (*cmp)(const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *f1, const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *f2)</code> </td><td>An optional function to determine whether two open files have the same key. If this function is not present then the library assumes that two files will never be the same.  </td></tr>
<tr>
<td><code>int (*query)(const <a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *f, unsigned long *flags)</code> </td><td>An optional function to determine which library optimizations a driver can support.  </td></tr>
<tr>
<td><code>haddr_t (*alloc)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, hsize_t size)</code> </td><td>An optional function to allocate space in the file.  </td></tr>
<tr>
<td><code>herr_t (*free)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, haddr_t addr, hsize_t size)</code> </td><td>An optional function to free space in the file.  </td></tr>
<tr>
<td><code>haddr_t (*get_eoa)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>A function to query how much of the format address space has been allocated.  </td></tr>
<tr>
<td><code>herr_t (*set_eoa)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, haddr_t)</code> </td><td>A function to set the end of address space.  </td></tr>
<tr>
<td><code>haddr_t (*get_eof)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>A function to return the current end-of-file marker value.  </td></tr>
<tr>
<td><code>herr_t (*read)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, hsize_t size, void *buffer)</code> </td><td>A function to read data from a file.  </td></tr>
<tr>
<td><code>herr_t (*write)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file, H5FD_mem_t type, hid_t dxpl, haddr_t addr, hsize_t size, const void *buffer)</code> </td><td>A function to write data to a file.  </td></tr>
<tr>
<td><code>herr_t (*flush)(<a class="el" href="struct_h5_f_d__t.html">H5FD_t</a> *file)</code> </td><td>A function which flushes cached data to the file.  </td></tr>
<tr>
<td><code>H5FD_mem_t fl_map[H5FD_MEM_NTYPES]</code> </td><td>An array which maps a file allocation request type to a free list.  </td></tr>
</table>
<p>Example: The sec2 driver would be registered as: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="struct_h5_f_d__class__t.html">H5FD_class_t</a> H5FD_sec2_g = {</div>
<div class="line">    <span class="stringliteral">&quot;sec2&quot;</span>,                                     <span class="comment">/*name                  */</span></div>
<div class="line">    MAXADDR,                                    <span class="comment">/*maxaddr               */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*sb_size               */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*sb_encode             */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*sb_decode             */</span></div>
<div class="line">    0,                                          <span class="comment">/*fapl_size             */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*fapl_get              */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*fapl_copy             */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*fapl_free             */</span></div>
<div class="line">    0,                                          <span class="comment">/*dxpl_size             */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*dxpl_copy             */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*dxpl_free             */</span></div>
<div class="line">    H5FD_sec2_open,                             <span class="comment">/*open                  */</span></div>
<div class="line">    H5FD_sec2_close,                            <span class="comment">/*close                 */</span></div>
<div class="line">    H5FD_sec2_cmp,                              <span class="comment">/*cmp                   */</span></div>
<div class="line">    H5FD_sec2_query,                            <span class="comment">/*query                 */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*alloc                 */</span></div>
<div class="line">    NULL,                                       <span class="comment">/*free                  */</span></div>
<div class="line">    H5FD_sec2_get_eoa,                          <span class="comment">/*get_eoa               */</span></div>
<div class="line">    H5FD_sec2_set_eoa,                          <span class="comment">/*set_eoa               */</span></div>
<div class="line">    H5FD_sec2_get_eof,                          <span class="comment">/*get_eof               */</span></div>
<div class="line">    H5FD_sec2_read,                             <span class="comment">/*read                  */</span></div>
<div class="line">    H5FD_sec2_write,                            <span class="comment">/*write                 */</span></div>
<div class="line">    H5FD_sec2_flush,                            <span class="comment">/*flush                 */</span></div>
<div class="line">    <a class="code hl_define" href="_h5_f_ddevelop_8h.html#a4c63846487a43d7a3d589ac2852c9078">H5FD_FLMAP_SINGLE</a>,                          <span class="comment">/*fl_map                */</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a></div>
<div class="line">H5FD_sec2_init(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!H5FD_SEC2_g) {</div>
<div class="line">        H5FD_SEC2_g = <a class="code hl_function" href="_h5_f_ddevelop_8h.html#a576ba6b6ebc34ae422bf40700a4c372d">H5FDregister</a>(&amp;H5FD_sec2_g);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> H5FD_SEC2_g;</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_f_ddevelop_8h_html_a4c63846487a43d7a3d589ac2852c9078"><div class="ttname"><a href="_h5_f_ddevelop_8h.html#a4c63846487a43d7a3d589ac2852c9078">H5FD_FLMAP_SINGLE</a></div><div class="ttdeci">#define H5FD_FLMAP_SINGLE</div><div class="ttdef"><b>Definition</b> H5FDdevelop.h:148</div></div>
<div class="ttc" id="a_h5_f_ddevelop_8h_html_a576ba6b6ebc34ae422bf40700a4c372d"><div class="ttname"><a href="_h5_f_ddevelop_8h.html#a576ba6b6ebc34ae422bf40700a4c372d">H5FDregister</a></div><div class="ttdeci">hid_t H5FDregister(const H5FD_class_t *cls)</div></div>
</div><!-- fragment --><p>A driver can be removed from the library by unregistering it </p><table class="doxtable">
<tr>
<td><code>herr_t H5Dunregister (hid_t driver)</code> </td><td>Where driver is the ID number returned when the driver was registered.  </td></tr>
</table>
<p>Unregistering a driver makes it unusable for creating new file access or data transfer property lists but doesn't affect any property lists or files that already use that driver.</p>
<h2><a class="anchor" id="subsec_vfl_reg_prog"></a>
Programming Note for C++ Developers Using C Functions</h2>
<p>If a C routine that takes a function pointer as an argument is called from within C++ code, the C routine should be returned from normally.</p>
<p>Examples of this kind of routine include callbacks such as <a class="el" href="group___l_a_p_l.html#ga8850042eed51777866d7bd0d050cfdc2" title="Sets the external link traversal callback function in a link access property list.">H5Pset_elink_cb</a> and <a class="el" href="group___d_x_p_l.html#ga10a80b29444d933da1aa2003f46cf003" title="Sets user-defined datatype conversion callback function.">H5Pset_type_conv_cb</a> and functions such as <a class="el" href="group___c_o_n_v.html#ga9442478475a03357ee47fa035df0228a" title="Converts data from one specified datatype to another.">H5Tconvert</a> and <a class="el" href="group___h5_e.html#ga4ecc0f6a1ea5bb821373a5a7b8070655" title="Walks the specified error stack, calling the specified function.">H5Ewalk2</a>.</p>
<p>Exiting the routine in its normal fashion allows the HDF5 C Library to clean up its work properly. In other words, if the C++ application jumps out of the routine back to the C++ catch statement, the library is not given the opportunity to close any temporary data structures that were set up when the routine was called. The C++ application should save some state as the routine is started so that any problem that occurs might be diagnosed.</p>
<h1><a class="anchor" id="sec_vfl_query"></a>
Querying Driver Information</h1>
<table class="doxtable">
<tr>
<td><code>void * H5Pget_driver_data (hid_t fapl)<br  />
void * H5Pget_driver_data (hid_t fxpl)</code> </td><td>This function is intended to be used by driver functions, not applications. It returns a pointer directly into the file access property list fapl which is a copy of the driver's file access mode originally provided to the H5Pset_driver function. If its argument is a data transfer property list fxpl then it returns a pointer to the driver-specific data transfer information instead.   </td></tr>
</table>
<h1><a class="anchor" id="sec_vfl_misc"></a>
Miscellaneous</h1>
<p>The various private H5F_low_* functions will be replaced by public H5FD* functions so they can be called from drivers.</p>
<p>All private functions H5F_addr_* which operate on addresses will be renamed as public functions by removing the first underscore so they can be called by drivers.</p>
<p>The haddr_t address data type will be passed by value throughout the library. The original intent was that this type would eventually be a union of file address types for the various drivers and may become quite large, but that was back when drivers were part of HDF5. It will become an alias for an unsigned integer type (32 or 64 bits depending on how the library was configured).</p>
<p>The various H5F*.c driver files will be renamed H5FD*.c and each will have a corresponding header file. All driver functions except the initializer and API will be declared static.</p>
<p>This documentation didn't cover optimization functions which would be useful to drivers like MPI-IO. Some drivers may be able to perform data pipeline operations more efficiently than HDF5 and need to be given a chance to override those parts of the pipeline. The pipeline would be designed to call various H5FD optimization functions at various points which return one of three values: the operation is not implemented by the driver, the operation is implemented but failed in a non-recoverable manner, the operation is implemented and succeeded.</p>
<p>Various parts of HDF5 check the only the top-level file driver and do something special if it is the MPI-IO driver. However, we might want to be able to put the MPI-IO driver under other drivers such as the raw part of a split driver or under a debug driver whose sole purpose is to accumulate statistics as it passes all requests through to the MPI-IO driver. Therefore we will probably need a function which takes a format address and or object type and returns the driver which would have been used at the lowest level to process the request.</p>
<hr  />
<p> Navigate back: <a class="el" href="index.html">Main</a> / <a class="el" href="_t_n.html">Technical Notes</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
